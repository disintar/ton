name: windows-build-ton-cpython

on:
  push:
    branches: [ feature/windows ]
  pull_request:
    branches: [ feature/windows ]
  workflow_dispatch:
  workflow_call:

defaults:
  run:
    shell: cmd

jobs:
  build:
    strategy:
      matrix:
        platform: [x64, arm64]
        python: ["3.9", "3.10", "3.11", "3.12", "3.13"]
        exclude:
          - platform: arm64
            python: "3.9"
        include:
          - platform: x64
            runner: windows-2022
            arch: x86_64
          - platform: arm64
            runner: windows-11-arm
            arch: aarch64
    runs-on: ${{ matrix.runner }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Python (x64)
        if: matrix.platform == 'x64'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      - name: Install Python (Windows ARM64)
        if: matrix.platform == 'arm64'
        shell: powershell
        run: |
          $ver = "${{ matrix.python }}"
          $parts = $ver -split '\.'
          $major = [int]$parts[0]
          $minor = [int]$parts[1]
          $nextMinor = $minor + 1
          $lower = [version]"$major.$minor.0"
          $upper = [version]"$major.$nextMinor.0"
          Write-Host "Resolving pythonarm64 version in range [$lower,$upper)..."
          $nugetSource = 'https://api.nuget.org/v3/index.json'
          $list = & nuget list pythonarm64 -AllVersions -Source $nugetSource 2>$null
          $versions = @()
          if ($list) {
            foreach ($line in $list) {
              if ($line -match 'pythonarm64\s+([0-9]+\.[0-9]+\.[0-9]+)') {
                $versions += [version]$Matches[1]
              }
            }
          }
          $cand = $versions | Where-Object { $_ -ge $lower -and $_ -lt $upper } | Sort-Object -Descending | Select-Object -First 1
          if ($cand) {
            $exact = $cand.ToString()
            Write-Host "Installing Python ARM64 $exact via NuGet"
            $outDir = Join-Path $env:RUNNER_TEMP 'pyarm'
            New-Item -ItemType Directory -Force -Path $outDir | Out-Null
            nuget install pythonarm64 -Version $exact -OutputDirectory $outDir -Source $nugetSource
            $pkg = Get-ChildItem $outDir -Directory | Where-Object { $_.Name -like "pythonarm64.$exact*" } | Sort-Object Name -Descending | Select-Object -First 1
            if (-not $pkg) { $pkg = Get-ChildItem $outDir -Directory | Where-Object { $_.Name -like 'pythonarm64*' } | Sort-Object Name -Descending | Select-Object -First 1 }
            if (-not $pkg) { Write-Error 'Failed to install pythonarm64 via NuGet'; exit 1 }
            $tools = Join-Path $pkg.FullName 'tools'
            if (-not (Test-Path (Join-Path $tools 'python.exe'))) { Write-Error 'python.exe not found in NuGet tools folder'; exit 1 }
            # Add python to PATH for subsequent steps
            echo $tools >> $env:GITHUB_PATH
            & (Join-Path $tools 'python.exe') --version
            # Ensure pip is available
            & (Join-Path $tools 'python.exe') -m ensurepip --upgrade
          } else {
            Write-Warning "No pythonarm64 NuGet package found within [$lower,$upper). Falling back to official python.org ARM64 installer."
            $maxPatch = 30
            $foundUrl = $null
            for ($p = $maxPatch; $p -ge 0; $p--) {
              $verExact = "$major.$minor.$p"
              $url = "https://www.python.org/ftp/python/$verExact/python-$verExact-arm64.exe"
              try {
                $resp = Invoke-WebRequest -Uri $url -Method Head -UseBasicParsing -ErrorAction Stop
                if ($resp.StatusCode -lt 400) { $foundUrl = $url; Write-Host "Found installer at $url"; break }
              } catch { }
            }
            if (-not $foundUrl) { Write-Error "Could not locate official ARM64 installer for $major.$minor.x on python.org"; exit 1 }
            $dlDir = Join-Path $env:RUNNER_TEMP 'pyarm_official'
            New-Item -ItemType Directory -Force -Path $dlDir | Out-Null
            $installer = Join-Path $dlDir 'python-arm64.exe'
            Write-Host "Downloading $foundUrl"
            Invoke-WebRequest -Uri $foundUrl -OutFile $installer -UseBasicParsing
            $target = Join-Path $env:RUNNER_TEMP "pyarm_install_${major}${minor}"
            New-Item -ItemType Directory -Force -Path $target | Out-Null
            $args = @('/quiet', 'InstallAllUsers=0', 'Include_pip=1', 'PrependPath=0', "TargetDir=$target")
            $proc = Start-Process -FilePath $installer -ArgumentList $args -Wait -PassThru
            if ($proc.ExitCode -ne 0) { Write-Error "Python installer failed with exit code $($proc.ExitCode)"; exit $proc.ExitCode }
            $py = Join-Path $target 'python.exe'
            if (-not (Test-Path $py)) { $py = Join-Path $target 'python3.exe' }
            if (-not (Test-Path $py)) { Write-Error 'python.exe not found after installer completed'; exit 1 }
            $scripts = Join-Path $target 'Scripts'
            # Add to PATH for subsequent steps
            echo $target >> $env:GITHUB_PATH
            if (Test-Path $scripts) { echo $scripts >> $env:GITHUB_PATH }
            & $py --version
            # Ensure pip is available (embeddable typically lacks pip, but installer with Include_pip should provide it)
            try { & $py -m pip --version } catch { & $py -m ensurepip --upgrade }
          }

      - name: Compute Python short version
        id: py-short
        shell: bash
        run: |
          echo "PY_SHORT=${{ matrix.python }}" | tr -d '.' >> "$GITHUB_ENV"

      - name: Print OS info
        run: |
          systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

      - name: Compute 3pp cache key
        id: third-party-key
        shell: bash
        run: |
          echo "key=${{ runner.os }}-${{ runner.arch }}-${PY_SHORT}-3pp-$(sha256sum ./assembly/native/build-3pp.bat | cut -c1-16)" >> "$GITHUB_OUTPUT"

      - name: Restore 3pp
        uses: actions/cache/restore@v4
        with:
          path: ${{ runner.temp }}\3pp_clear\
          key: ${{ steps.third-party-key.outputs.key }}

      - name: Build 3pp
        run: |
          call "C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat"
          call assembly\native\build-3pp.bat

      - name: Check 3pp build status
        id: check-third-party
        shell: powershell
        run: |
          $statusPath = Join-Path $env:RUNNER_TEMP '3pp/3pp_status.txt'
          if (Test-Path $statusPath) {
            $content = Get-Content $statusPath -Raw
            if ($content -match 'NEED_CACHE=true') {
              echo "cache=true" >> $env:GITHUB_OUTPUT
            } else {
              echo "cache=false" >> $env:GITHUB_OUTPUT
            }
          } else {
            echo "cache=false" >> $env:GITHUB_OUTPUT
          }

      - name: Save 3pp
        if: steps.check-third-party.outputs.cache == 'true' && github.event_name != 'pull_request'
        uses: actions/cache/save@v4
        with:
          path: ${{ runner.temp }}\3pp_clear\
          key: ${{ steps.third-party-key.outputs.key }}

      - name: Build TON (Windows)
        run: |
          git submodule sync --recursive
          git submodule update
          copy assembly\native\build-windows-github-2022.bat .
          copy assembly\native\build-windows-2022.bat .
          echo Using RDKAFKA_ROOT=%RDKAFKA_ROOT%
          build-windows-github-2022.bat Enterprise

      - name: Set release env
        shell: bash
        run: |
          echo "RELEASE_NAME=ton-cpython-${PY_SHORT}-${{ matrix.arch }}-windows" >> $GITHUB_ENV

      - name: Simple python import test
        run: |
          cd artifacts && ls && python -c "import python_ton"

      - name: Upload artifacts
        if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.RELEASE_NAME }}
          path: artifacts

      - name: Create release
        if: github.event_name != 'pull_request'
        shell: bash
        run: |
          gh release delete -y "$RELEASE_NAME" || true
          gh release create --notes "Windows Python ${{ matrix.python }} build" "$RELEASE_NAME" artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
